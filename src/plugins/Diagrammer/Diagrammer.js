/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 0.14.0 from webgme on Sat Jan 30 2016 07:34:45 GMT-0600 (CST).
 */

define([
    'plugin/PluginConfig',
    'plugin/PluginBase',
    './dagre.min.js',
    './lua.js'  // defines luajs globally
], function (
    PluginConfig,
    PluginBase,
    dagre
) {
    'use strict';

    var WIDTH = 120,
        HEIGHT = 80;
    /**
     * Initializes a new instance of Diagrammer.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin Diagrammer.
     * @constructor
     */
    var Diagrammer = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.baseClasses = [];
        this.originalVars = null;
        this.classNodes = null;
    };

    // Prototypal inheritance from PluginBase.
    Diagrammer.prototype = Object.create(PluginBase.prototype);
    Diagrammer.prototype.constructor = Diagrammer;

    /**
     * Gets the name of the Diagrammer.
     * @returns {string} The name of the plugin.
     * @public
     */
    Diagrammer.prototype.getName = function () {
        return 'Diagrammer';
    };

    /**
     * Gets the semantic version (semver.org) of the Diagrammer.
     * @returns {string} The version of the plugin.
     * @public
     */
    Diagrammer.prototype.getVersion = function () {
        return '0.1.0';
    };

    /**
     * Gets the configuration structure for the Diagrammer.
     * The ConfigurationStructure defines the configuration for the plugin
     * and will be used to populate the GUI when invoking the plugin from webGME.
     * @returns {object} The version of the plugin.
     * @public
     */
    Diagrammer.prototype.getConfigStructure = function () {
        return [
            {
                name: 'source',
                displayName: 'Source Code',
                description: 'Lua source to diagram',
                value: '',
                valueType: 'asset',
                readOnly: false
            }
        ];
    };


    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    Diagrammer.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var srcHash = this.getCurrentConfig().source;

        this.baseClasses = [];
        this.originalVars = [];
        this.classNodes = {};

        this.blobClient.getMetadata(srcHash, (err, md) => {
            if (err) {
                return callback(err);
            }
            // Create the diagram node
            this.diagramNode = this.core.createNode({
                parent: this.rootNode,
                base: this.META.Diagram
            });
            this.core.setAttribute(this.diagramNode, 'name', md.name.replace(/\.[a-zA-Z]+$/, ''));

            this.blobClient.getObject(srcHash, (err, buffer) => {
                if (err) {
                    return callback(err);
                }

                var src = String.fromCharCode.apply(null, new Uint8Array(buffer)),
                    context = luajs.newContext(),
                    bin;

                // load the lua into js
                context.loadStdLib();
                this.prepare(context);
                bin = context.loadString(src, context._G);
                bin();
                this.resolveClassNames(context);
                this.diagram();

                this.result.setSuccess(true);
                this.save('Created diagram!', (err) => {
                    callback(null, this.result);
                });
            });
        });
    };

    Diagrammer.prototype.prepare = function (context) {
        var varFrame = context._G.stringMap,
            oldSetMetaTable = varFrame.setmetatable,
            self = this;

        // Override setmetatable
        varFrame.setmetatable = function (child, base) {
            // Create the nodes and connection
            // TODO
            self.recordInheritance(child, base);

            // Retrieve the name of the object...?
            return oldSetMetaTable.call(this, child, base);
        }

        // Get the current variables
        this.originalVars = this._getAllVarNames(context);
    };

    Diagrammer.prototype.resolveClassNames = function (context) {
        // for every variable, (if it resolves to a table),
        var vars = this._getNewVars(context),
            getClassName = (obj) => {
                for (var name in vars) {
                    if (vars[name] === obj) {
                        return name;
                    }
                }
                return 'unknown';
            };

        this.baseClasses = this.baseClasses
            .map(pair => pair.map(getClassName));

        console.log('baseClasses:', 
            this.baseClasses.map(p => p.join('->')).join(' | ')
        );
    };

    Diagrammer.prototype._getNewVars = function (context) {
        var vars = this._getAllVarNames(context),
            names = _.difference(vars, this.originalVars),
            result = {};
        names.forEach(name => result[name] = context._G.stringMap[name]);
        return result;
    };

    Diagrammer.prototype._getAllVarNames = function (context) {
        return Object.keys(context._G.stringMap);
    };

    Diagrammer.prototype.recordInheritance = function (child, base) {
        // Verify that child and base exist
        this.baseClasses.push([child, base]);
    };

    Diagrammer.prototype.diagram = function () {
        this.diagramClasses();
        this.diagramInheritance();
        this.updatePositions();
    };

    Diagrammer.prototype.diagramClasses = function () {
        var classes = [];

        this.baseClasses
            .reduce((l1, l2) => l1.concat(l2), [])
            .forEach(name => classes.indexOf(name) === -1 && classes.push(name));

        // Create a webgme node for each of these
        classes.forEach(name => this.createClass(name));
    };

    Diagrammer.prototype.createClass = function (name) {
        var node = this.core.createNode({
            parent: this.diagramNode,
            base: this.META.Class
        });
        this.core.setAttribute(node, 'name', name);
        this.classNodes[name] = node;
    };

    Diagrammer.prototype.diagramInheritance = function () {
        // Diagram inheritance
        this.baseClasses
            .forEach((pair) => this.createBaseConn.apply(this, pair));
    };

    Diagrammer.prototype.createBaseConn = function (child, base) {
        var srcNode = this.classNodes[child],
            dstNode = this.classNodes[base],
            conn = this.core.createNode({
                parent: this.diagramNode,
                base: this.META.base
            });
        this.core.setPointer(conn, 'src', srcNode);
        this.core.setPointer(conn, 'dst', dstNode);
    };

    Diagrammer.prototype.updatePositions = function () {
        // Create the graph in dagre and get the positions
        this.logger.info('Positioning nodes');
        var graph = new dagre.graphlib.Graph(),
            nodeNames = Object.keys(this.classNodes);

        // Add the nodes
        graph.setGraph({});
        graph.setDefaultEdgeLabel(function() { return {}; });
        nodeNames.forEach(name => {
            graph.setNode(name, {
                label: name,
                x: 100,
                y: 100,
                width: WIDTH,
                height: HEIGHT
            });
        });

        // Add connections
        this.baseClasses.forEach(pair => {
            var src = pair[0],
                dst = pair[1];

            console.log('connecting ' + src + ' and ' + dst);
            graph.setEdge(dst, src);
        });

        // Calculate positions
        dagre.layout(graph);

        // Set the positions
        graph.nodes().forEach(name => {
            var pos = {
                x: graph.node(name).x,
                y: graph.node(name).y
            };
            this.core.setRegistry(this.classNodes[name], 'position', pos);
        });
    };

    Diagrammer.prototype.positionNodes = function () {
    };

    return Diagrammer;
});
